<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flipo Flip 物理數據分析 (Camera Fix)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #FF5252;
            --accent-hover: #FF1744;
            --border-color: #333;
            --graph-bg: #181818;
            --graph-v: #40C4FF;     
            --graph-v-tip: #E040FB; 
            --graph-w: #FFD740;
            --graph-a: #FF5252;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* 左側控制面板 */
        #controls {
            width: 320px;
            min-width: 320px;
            background-color: var(--panel-bg);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            z-index: 20;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0 0 10px 0;
            color: var(--accent-color);
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .control-group {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .control-group h3 {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
            cursor: pointer;
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            font-family: monospace;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            margin-top: 5px;
        }

        button:hover { background-color: var(--accent-hover); }

        /* 右側主區域 */
        #main-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            background-color: #0a0a0a;
            border-bottom: 1px solid var(--border-color);
        }

        #stats-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 0.82rem;
            border: 1px solid #444;
            z-index: 10;
            pointer-events: none;
            min-width: 200px;
        }

        .stat-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 4px; }
        .stat-value { color: var(--accent-color); }
        .stat-tip { color: var(--graph-v-tip); }

        /* 圖表區域 */
        #graphs-container {
            height: 240px;
            background-color: #111;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            border-top: 1px solid var(--border-color);
        }

        .graph-box {
            background-color: var(--graph-bg);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .graph-title {
            font-size: 0.72rem;
            padding: 6px 10px;
            color: #999;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid #222;
        }

        .graph-canvas { flex-grow: 1; width: 100%; height: 100%; }

        #watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            opacity: 0.3;
            font-size: 0.8rem;
            pointer-events: none;
        }
        
        .correction-note {
            font-size: 0.75rem;
            color: #ff9e80;
            margin-top: 5px;
            line-height: 1.4;
            background: rgba(255,87,34,0.1);
            padding: 8px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>Flipo Flip 高精度分析</h1>
        
        <div class="control-group">
            <h3>環境設定 (Incline)</h3>
            <label>斜面角度: <span id="val-slopeAngle" class="value-display">20</span>°</label>
            <input type="range" id="slopeAngle" min="5" max="45" step="1" value="20" oninput="resetSimulation()">
        </div>

        <div class="control-group">
            <h3>物理性質 (Physics)</h3>
            
            <div class="correction-note">
                攝影機修復版<br>
                摩擦與迭代維持高精度
            </div>

            <label>表面摩擦力 (Traction): <span id="val-friction" class="value-display">0.8</span></label>
            <input type="range" id="friction" min="0.1" max="1.0" step="0.05" value="0.8" oninput="resetSimulation()">

            <label>彈性係數 (Bounciness): <span id="val-restitution" class="value-display">0.6</span></label>
            <input type="range" id="restitution" min="0.0" max="1.0" step="0.05" value="0.6" oninput="resetSimulation()">

            <label>滾動阻力 (α): <span id="val-rollingFriction" class="value-display">0.00</span></label>
            <input type="range" id="rollingFriction" min="0.0" max="0.05" step="0.001" value="0.00" oninput="resetSimulation()">
        </div>

        <div class="control-group">
            <h3>物體幾何 (Geometry)</h3>
            <label>短軸半徑: <span id="val-radius" class="value-display">0.02</span> m</label>
            <input type="range" id="radius" min="0.01" max="0.05" step="0.001" value="0.02" oninput="resetSimulation()">

            <label>長寬比: <span id="val-aspectRatio" class="value-display">1.8</span></label>
            <input type="range" id="aspectRatio" min="1.1" max="5.0" step="0.1" value="1.8" oninput="resetSimulation()">
        </div>

        <button onclick="resetSimulation()">重新開始實驗</button>
        <button id="pauseBtn" onclick="togglePause()" style="background-color: #444; color: white;">暫停</button>
        <button onclick="exportData()" style="background-color: #0091EA; color: white;">匯出 CSV 數據</button>
    </div>

    <div id="main-area">
        <div id="canvas-wrapper">
            <div id="stats-panel">
                <div class="stat-row">時間 (t): <span id="stat-time" class="stat-value">0.00</span> s</div>
                <div class="stat-row">質心速 (v_cm): <span id="stat-vel" class="stat-value">0.00</span> m/s</div>
                <div class="stat-row">頂端速 (v_tip): <span id="stat-vel-tip" class="stat-tip">0.00</span> m/s</div>
                <div class="stat-row">角速度 (ω): <span id="stat-omega" class="stat-value">0.00</span> rad/s</div>
                <div class="stat-row">相對角 (θ): <span id="stat-theta" class="stat-value">1.57</span> rad</div>
            </div>
            <div id="canvas-container" style="width:100%; height:100%;"></div>
            <div id="watermark">物理實驗室 | Camera Fixed</div>
        </div>

        <div id="graphs-container">
            <div class="graph-box">
                <div class="graph-title">
                    <span>v-t 速度 (m/s)</span>
                    <span><b style="color:var(--graph-v)">CoM</b> <b style="color:var(--graph-v-tip)">Tip</b></span>
                </div>
                <canvas id="canvas-v-t" class="graph-canvas"></canvas>
            </div>
            <div class="graph-box">
                <div class="graph-title"><span>ω-t 角速度 (rad/s)</span></div>
                <canvas id="canvas-omega-t" class="graph-canvas"></canvas>
            </div>
            <div class="graph-box">
                <div class="graph-title"><span>θ-t 相對角度 (rad)</span></div>
                <canvas id="canvas-theta-t" class="graph-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        const PX_PER_METER = 2000; 
        const MAX_POINTS = 600;

        const { Engine, Render, Runner, Bodies, Body, Composite, Events, Vector, Bounds } = Matter;
        let engine, render, runner, flipoBody, slopeBody;
        let simulationTime = 0;
        let isPaused = false;
        let dataLog = [];
        let graphV, graphOmega, graphTheta;

        class RealtimeGraph {
            constructor(canvasId, colors) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.colors = Array.isArray(colors) ? colors : [colors];
                this.datasets = this.colors.map(() => []);
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width * devicePixelRatio;
                this.canvas.height = (rect.height - 30) * devicePixelRatio;
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height - 30;
            }

            push(t, values) {
                const vals = Array.isArray(values) ? values : [values];
                vals.forEach((v, i) => {
                    if (this.datasets[i]) {
                        if (!isFinite(v) || isNaN(v)) return;
                        this.datasets[i].push({t, val: v});
                        if (this.datasets[i].length > MAX_POINTS) this.datasets[i].shift();
                    }
                });
                this.draw();
            }

            draw() {
                const { ctx, width, height, datasets, colors } = this;
                ctx.clearRect(0, 0, width, height);
                
                const hasData = datasets.some(ds => ds.length > 1);
                if (!hasData) return;

                let minT = Infinity, maxT = -Infinity;
                let allVals = [];

                datasets.forEach(ds => {
                    if (ds.length > 0) {
                        if (ds[0].t < minT) minT = ds[0].t;
                        if (ds[ds.length-1].t > maxT) maxT = ds[ds.length-1].t;
                        ds.forEach(d => allVals.push(Math.abs(d.val)));
                    }
                });

                const tr = maxT - minT || 1;
                
                let maxVal = Math.max(...allVals, 0.1);
                if (!isFinite(maxVal)) maxVal = 1; 
                maxVal *= 1.2;

                datasets.forEach((data, dIdx) => {
                    if (data.length < 2) return;

                    ctx.beginPath();
                    ctx.strokeStyle = colors[dIdx];
                    ctx.lineWidth = 2.5;
                    ctx.lineJoin = 'round';
                    
                    let hasStarted = false;
                    data.forEach((p) => {
                        const x = ((p.t - minT) / tr) * width;
                        const y = height - (Math.abs(p.val) / maxVal) * height * 0.85 - (height * 0.05);
                        
                        if (isFinite(x) && isFinite(y)) {
                            if (!hasStarted) {
                                ctx.moveTo(x, y);
                                hasStarted = true;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    });
                    ctx.stroke();
                    
                    const lastVal = data[data.length-1].val;
                    ctx.fillStyle = colors[dIdx];
                    ctx.font = 'bold 11px Consolas, monospace';
                    ctx.fillText(lastVal.toFixed(2), 6, 14 + dIdx * 14);
                });
            }

            reset() { 
                this.datasets.forEach(ds => ds.length = 0); 
                this.draw(); 
            }
        }

        function init() {
            engine = Engine.create();
            engine.positionIterations = 50;
            engine.velocityIterations = 50;
            engine.gravity.y = 1; 

            const container = document.getElementById('canvas-container');
            const wrapper = document.getElementById('canvas-wrapper');
            
            render = Render.create({
                element: container,
                engine: engine,
                options: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    background: 'transparent',
                    wireframes: false,
                    showAngleIndicator: false,
                    // 移除 pixelRatio 以避免座標系混淆
                    hasBounds: true // 啟用邊界控制
                }
            });

            runner = Runner.create({
                isFixed: true,
                delta: 1000 / 60
            });
            
            graphV = new RealtimeGraph('canvas-v-t', ['#40C4FF', '#E040FB']);
            graphOmega = new RealtimeGraph('canvas-omega-t', '#FFD740');
            graphTheta = new RealtimeGraph('canvas-theta-t', '#FF5252');

            Events.on(render, 'afterRender', updateLoop);
            
            Render.run(render);
            Runner.run(runner, engine);
            
            resetSimulation();
        }

        function resetSimulation() {
            Composite.clear(engine.world);
            simulationTime = 0;
            dataLog = [];
            graphV.reset();
            graphOmega.reset();
            graphTheta.reset();

            const slopeDeg = parseFloat(document.getElementById('slopeAngle').value);
            const slopeRad = slopeDeg * Math.PI / 180;
            const radiusM = parseFloat(document.getElementById('radius').value);
            const ratio = parseFloat(document.getElementById('aspectRatio').value);
            const fric = parseFloat(document.getElementById('friction').value);
            const rest = parseFloat(document.getElementById('restitution').value);
            const rollFric = parseFloat(document.getElementById('rollingFriction').value);

            // 錨點定位：確保物體產生在畫面正中央
            const viewWidth = render.options.width;
            const viewHeight = render.options.height;
            const anchorX = viewWidth / 2;
            const anchorY = viewHeight / 2 + 100; // 稍微往下放一點
            
            const slopeWidth = 20000; 
            const slopeThickness = 40;
            
            const tHalf = slopeThickness / 2;
            const slopeCx = anchorX - Math.sin(slopeRad) * tHalf;
            const slopeCy = anchorY + Math.cos(slopeRad) * tHalf;

            slopeBody = Bodies.rectangle(slopeCx, slopeCy, slopeWidth, slopeThickness, {
                isStatic: true,
                angle: slopeRad,
                friction: fric,
                frictionStatic: fric,
                render: { fillStyle: '#333' }
            });

            const rPx = radiusM * PX_PER_METER;
            const standingHalfHeight = rPx * ratio; 
            
            const distFromSurface = standingHalfHeight + 0.1; 
            
            const ballX = anchorX + Math.sin(slopeRad) * distFromSurface;
            const ballY = anchorY - Math.cos(slopeRad) * distFromSurface;
            
            flipoBody = Bodies.circle(ballX, ballY, rPx, {
                friction: fric,
                frictionStatic: fric,
                restitution: rest,
                frictionAir: 0, 
                frictionAngular: rollFric,
                density: 0.005,
                render: { fillStyle: '#FF5252', strokeStyle: '#fff', lineWidth: 2 }
            });

            Body.scale(flipoBody, ratio, 1);
            Body.setAngle(flipoBody, slopeRad + Math.PI/2);
            
            Composite.add(engine.world, [slopeBody, flipoBody]);
            
            // 手動設定初始視角 (不使用 lookAt 以避免縮放錯誤)
            Bounds.shift(render.bounds, {
                x: anchorX - viewWidth / 2,
                y: anchorY - viewHeight / 2
            });
        }

        function updateLoop() {
            if (isPaused || !flipoBody) return;

            const radiusM = parseFloat(document.getElementById('radius').value);
            const ratio = parseFloat(document.getElementById('aspectRatio').value);
            const rPx = radiusM * PX_PER_METER;

            let dt = runner.delta / 1000; 
            simulationTime += dt;

            // --- 數據計算 ---
            const slopeRad = slopeBody.angle;
            let rawRelAngle = flipoBody.angle - slopeRad;
            let theta = Math.abs(Math.atan2(Math.sin(rawRelAngle), Math.cos(rawRelAngle)));
            if (theta > Math.PI/2) theta = Math.PI - theta;

            const omega = flipoBody.angularVelocity / dt * 16.6; 
            const omegaAbs = Math.abs(omega);

            const v_cm_ms = Vector.magnitude(flipoBody.velocity) / PX_PER_METER / dt * 16.6;

            const rot = flipoBody.angle;
            const rx = Math.cos(rot) * (rPx * ratio);
            const ry = Math.sin(rot) * (rPx * ratio);
            const vx_cm = flipoBody.velocity.x; 
            const vy_cm = flipoBody.velocity.y;
            const angVel = flipoBody.angularVelocity;
            const vx_tip_world = vx_cm - angVel * ry; 
            const vy_tip_world = vy_cm + angVel * rx;
            const v_tip_ms = Math.sqrt(vx_tip_world**2 + vy_tip_world**2) / PX_PER_METER / dt * 16.6;

            // 顯示
            document.getElementById('stat-time').innerText = simulationTime.toFixed(2);
            document.getElementById('stat-vel').innerText = v_cm_ms.toFixed(3);
            document.getElementById('stat-vel-tip').innerText = v_tip_ms.toFixed(3);
            document.getElementById('stat-omega').innerText = omegaAbs.toFixed(2);
            document.getElementById('stat-theta').innerText = theta.toFixed(3);

            // 繪圖
            if (simulationTime > 0.05 && Math.floor(simulationTime * 1000) % 48 < 16) { 
                graphV.push(simulationTime, [v_cm_ms, v_tip_ms]); 
                graphOmega.push(simulationTime, omegaAbs);
                graphTheta.push(simulationTime, theta);
                dataLog.push({t: simulationTime.toFixed(4), v_cm: v_cm_ms.toFixed(4), v_tip: v_tip_ms.toFixed(4), omega: omegaAbs.toFixed(4), theta: theta.toFixed(4)});
            }

            // 攝影機跟隨 (手動更新 Bounds 以保持 1:1 比例)
            const viewWidth = render.options.width;
            const viewHeight = render.options.height;
            
            // 將畫面中心設定在物體位置
            render.bounds.min.x = flipoBody.position.x - viewWidth / 2;
            render.bounds.max.x = flipoBody.position.x + viewWidth / 2;
            render.bounds.min.y = flipoBody.position.y - viewHeight / 2;
            render.bounds.max.y = flipoBody.position.y + viewHeight / 2;

            // 輔助線
            const ctx = render.context;
            ctx.save();
            ctx.translate(flipoBody.position.x, flipoBody.position.y);
            ctx.rotate(flipoBody.angle);
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.moveTo(-rPx * ratio, 0); ctx.lineTo(rPx * ratio, 0);
            ctx.stroke();
            ctx.beginPath();
            ctx.fillStyle = "#E040FB";
            ctx.arc(rPx * ratio, 0, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function togglePause() {
            isPaused = !isPaused;
            runner.enabled = !isPaused;
            document.getElementById('pauseBtn').innerText = isPaused ? "繼續" : "暫停";
        }

        function exportData() {
            if (dataLog.length === 0) {
                alert("無數據可匯出");
                return;
            }
            let csv = "\uFEFFTime(s),V_CoM(m/s),V_Tip(m/s),AngularVel(rad/s),Theta(rad)\n";
            dataLog.forEach(d => {
                csv += `${d.t},${d.v_cm},${d.v_tip},${d.omega},${d.theta}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flipo_high_precision_${Date.now()}.csv`;
            a.click();
        }

        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', e => {
                document.getElementById('val-' + e.target.id).innerText = e.target.value;
            });
        });

        window.onload = init;
        window.addEventListener('resize', () => {
            if(graphV) graphV.resize();
            if(graphOmega) graphOmega.resize();
            if(graphTheta) graphTheta.resize();
        });
    </script>
</body>
</html>

