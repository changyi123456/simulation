<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flipo Flip 物理數據分析 (完整控制版)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00E676;
            --accent-hover: #00C853;
            --border-color: #333;
            --graph-bg: #181818;
            --graph-v: #29B6F6;     /* 質心速度顏色 */
            --graph-v-tip: #EA80FC; /* 頂端速度顏色 (加亮) */
            --graph-w: #FFCA28;
            --graph-a: #F44336;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* 左側控制面板 */
        #controls {
            width: 320px;
            min-width: 320px;
            background-color: var(--panel-bg);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            z-index: 20;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0 0 10px 0;
            color: var(--accent-color);
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .control-group {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 8px;
        }

        .control-group h3 {
            margin: 0 0 8px 0;
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
        }

        label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--accent-color);
            cursor: pointer;
        }

        .value-display {
            color: var(--accent-color);
            font-weight: bold;
            font-family: monospace;
        }

        button {
            background-color: var(--accent-color);
            color: #000;
            border: none;
            padding: 12px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: 0.2s;
            margin-top: 5px;
        }

        button:hover { background-color: var(--accent-hover); }

        /* 右側主區域 */
        #main-area {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        #canvas-wrapper {
            flex-grow: 1;
            position: relative;
            background-color: #0a0a0a;
            border-bottom: 1px solid var(--border-color);
        }

        #stats-panel {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.85);
            padding: 12px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
            font-size: 0.82rem;
            border: 1px solid #444;
            z-index: 10;
            pointer-events: none;
            min-width: 200px;
        }

        .stat-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 4px; }
        .stat-value { color: var(--accent-color); }
        .stat-tip { color: var(--graph-v-tip); }

        /* 圖表區域 */
        #graphs-container {
            height: 240px;
            background-color: #111;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1px;
            border-top: 1px solid var(--border-color);
        }

        .graph-box {
            background-color: var(--graph-bg);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .graph-title {
            font-size: 0.72rem;
            padding: 6px 10px;
            color: #999;
            display: flex;
            justify-content: space-between;
            background: rgba(0,0,0,0.4);
            border-bottom: 1px solid #222;
        }

        .graph-canvas { flex-grow: 1; width: 100%; height: 100%; }

        #watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            opacity: 0.3;
            font-size: 0.8rem;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="controls">
        <h1>Flipo Flip 分析系統</h1>
        
        <div class="control-group">
            <h3>環境設定 (Incline)</h3>
            <label>斜面角度: <span id="val-slopeAngle" class="value-display">20</span>°</label>
            <input type="range" id="slopeAngle" min="5" max="45" step="1" value="20" oninput="resetSimulation()">
        </div>

        <div class="control-group">
            <h3>物理性質 (Physics)</h3>
            <label>表面摩擦力: <span id="val-friction" class="value-display">0.6</span></label>
            <input type="range" id="friction" min="0.1" max="1.0" step="0.05" value="0.6" oninput="resetSimulation()">

            <label>彈性係數: <span id="val-restitution" class="value-display">0.5</span></label>
            <input type="range" id="restitution" min="0.0" max="1.0" step="0.1" value="0.5" oninput="resetSimulation()">

            <label>滾動阻力 (α): <span id="val-rollingFriction" class="value-display">0.01</span></label>
            <input type="range" id="rollingFriction" min="0.0" max="0.1" step="0.005" value="0.01" oninput="resetSimulation()">
        </div>

        <div class="control-group">
            <h3>物體幾何 (Geometry)</h3>
            <label>短軸半徑: <span id="val-radius" class="value-display">0.02</span> m</label>
            <input type="range" id="radius" min="0.01" max="0.05" step="0.001" value="0.02" oninput="resetSimulation()">

            <label>長寬比: <span id="val-aspectRatio" class="value-display">1.8</span></label>
            <input type="range" id="aspectRatio" min="1.1" max="2.5" step="0.1" value="1.8" oninput="resetSimulation()">
        </div>

        <button onclick="resetSimulation()">重新開始實驗</button>
        <button id="pauseBtn" onclick="togglePause()" style="background-color: #444; color: white;">暫停</button>
        <button onclick="exportData()" style="background-color: #E65100; color: white;">匯出 CSV 數據</button>

        <div style="font-size: 0.75rem; color: #666; margin-top: 10px;">
            * 藍線：質心速度 | 紫線：頂端點速度<br>
            * 物體起始狀態：直立於斜面上
        </div>
    </div>

    <div id="main-area">
        <div id="canvas-wrapper">
            <div id="stats-panel">
                <div class="stat-row">時間 (t): <span id="stat-time" class="stat-value">0.00</span> s</div>
                <div class="stat-row">質心速 (v_cm): <span id="stat-vel" class="stat-value">0.00</span> m/s</div>
                <div class="stat-row">頂端速 (v_tip): <span id="stat-vel-tip" class="stat-tip">0.00</span> m/s</div>
                <div class="stat-row">角速度 (ω): <span id="stat-omega" class="stat-value">0.00</span> rad/s</div>
                <div class="stat-row">相對角 (θ): <span id="stat-theta" class="stat-value">1.57</span> rad</div>
            </div>
            <div id="canvas-container" style="width:100%; height:100%;"></div>
            <div id="watermark">物理實驗室 | IG: aiphysicsteacher</div>
        </div>

        <div id="graphs-container">
            <div class="graph-box">
                <div class="graph-title">
                    <span>v-t 速度 (m/s)</span>
                    <span><b style="color:var(--graph-v)">CoM</b> <b style="color:var(--graph-v-tip)">Tip</b></span>
                </div>
                <canvas id="canvas-v-t" class="graph-canvas"></canvas>
            </div>
            <div class="graph-box">
                <div class="graph-title"><span>ω-t 角速度 (rad/s)</span></div>
                <canvas id="canvas-omega-t" class="graph-canvas"></canvas>
            </div>
            <div class="graph-box">
                <div class="graph-title"><span>θ-t 相對角度 (rad)</span></div>
                <canvas id="canvas-theta-t" class="graph-canvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        const PX_PER_METER = 2000; 
        const MAX_POINTS = 600;

        const { Engine, Render, Runner, Bodies, Body, Composite, Events, Vector } = Matter;
        let engine, render, runner, flipoBody, slopeBody;
        let simulationTime = 0;
        let isPaused = false;
        let dataLog = [];
        let graphV, graphOmega, graphTheta;

        class RealtimeGraph {
            constructor(canvasId, colors) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.colors = Array.isArray(colors) ? colors : [colors];
                this.datasets = this.colors.map(() => []);
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                this.canvas.width = rect.width * devicePixelRatio;
                this.canvas.height = (rect.height - 30) * devicePixelRatio;
                this.ctx.scale(devicePixelRatio, devicePixelRatio);
                this.width = rect.width;
                this.height = rect.height - 30;
            }

            push(t, values) {
                const vals = Array.isArray(values) ? values : [values];
                vals.forEach((v, i) => {
                    if (this.datasets[i]) {
                        // 嚴格過濾無效數值
                        if (!isFinite(v) || isNaN(v)) return;
                        this.datasets[i].push({t, val: v});
                        if (this.datasets[i].length > MAX_POINTS) this.datasets[i].shift();
                    }
                });
                this.draw();
            }

            draw() {
                const { ctx, width, height, datasets, colors } = this;
                ctx.clearRect(0, 0, width, height);
                
                // 檢查是否有任何數據
                const hasData = datasets.some(ds => ds.length > 1);
                if (!hasData) return;

                // 計算所有數據集的時間範圍 (避免依賴單一數據集)
                let minT = Infinity, maxT = -Infinity;
                let allVals = [];

                datasets.forEach(ds => {
                    if (ds.length > 0) {
                        if (ds[0].t < minT) minT = ds[0].t;
                        if (ds[ds.length-1].t > maxT) maxT = ds[ds.length-1].t;
                        ds.forEach(d => allVals.push(Math.abs(d.val)));
                    }
                });

                const tr = maxT - minT || 1; // 時間範圍
                
                // Y軸最大值計算
                let maxVal = Math.max(...allVals, 0.1);
                if (!isFinite(maxVal)) maxVal = 1; 
                maxVal *= 1.2; // 留點邊距

                datasets.forEach((data, dIdx) => {
                    if (data.length < 2) return;

                    ctx.beginPath();
                    ctx.strokeStyle = colors[dIdx];
                    ctx.lineWidth = 2.5; // 加粗線條
                    ctx.lineJoin = 'round';
                    
                    let hasStarted = false;
                    data.forEach((p) => {
                        const x = ((p.t - minT) / tr) * width;
                        const y = height - (Math.abs(p.val) / maxVal) * height * 0.85 - (height * 0.05);
                        
                        if (isFinite(x) && isFinite(y)) {
                            if (!hasStarted) {
                                ctx.moveTo(x, y);
                                hasStarted = true;
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                    });
                    ctx.stroke();
                    
                    // 顯示最新數值
                    const lastVal = data[data.length-1].val;
                    ctx.fillStyle = colors[dIdx];
                    ctx.font = 'bold 11px Consolas, monospace';
                    ctx.fillText(lastVal.toFixed(2), 6, 14 + dIdx * 14);
                });
            }

            reset() { 
                this.datasets.forEach(ds => ds.length = 0); 
                this.draw(); 
            }
        }

        function init() {
            engine = Engine.create();
            // 修正物理運算迭代次數以提高穩定性
            engine.positionIterations = 8;
            engine.velocityIterations = 8;

            const container = document.getElementById('canvas-container');
            const wrapper = document.getElementById('canvas-wrapper');
            
            render = Render.create({
                element: container,
                engine: engine,
                options: {
                    width: wrapper.clientWidth,
                    height: wrapper.clientHeight,
                    background: 'transparent',
                    wireframes: false,
                    showAngleIndicator: false
                }
            });

            runner = Runner.create();
            graphV = new RealtimeGraph('canvas-v-t', ['#29B6F6', '#EA80FC']);
            graphOmega = new RealtimeGraph('canvas-omega-t', '#FFCA28');
            graphTheta = new RealtimeGraph('canvas-theta-t', '#F44336');

            Events.on(render, 'afterRender', updateLoop);
            
            Render.run(render);
            Runner.run(runner, engine);
            
            resetSimulation();
        }

        function resetSimulation() {
            Composite.clear(engine.world);
            simulationTime = 0;
            dataLog = [];
            graphV.reset();
            graphOmega.reset();
            graphTheta.reset();

            // 讀取所有參數
            const slopeDeg = parseFloat(document.getElementById('slopeAngle').value);
            const slopeRad = slopeDeg * Math.PI / 180;
            const radiusM = parseFloat(document.getElementById('radius').value);
            const ratio = parseFloat(document.getElementById('aspectRatio').value);
            const fric = parseFloat(document.getElementById('friction').value);
            const rest = parseFloat(document.getElementById('restitution').value);
            const rollFric = parseFloat(document.getElementById('rollingFriction').value);

            // 1. 斜面
            const slopeWidth = 10000;
            const slopeThickness = 40;
            const centerY = 600;
            slopeBody = Bodies.rectangle(slopeWidth/2, centerY, slopeWidth, slopeThickness, {
                isStatic: true,
                angle: slopeRad,
                friction: fric,
                render: { fillStyle: '#333' }
            });

            // 2. 物體 (橄欖球體)
            const rPx = radiusM * PX_PER_METER;
            const standingHalfHeight = rPx * ratio; 
            
            // 生成位置
            const spawnXOnSlope = 500; 
            const spawnYOnSlope = centerY + (spawnXOnSlope - slopeWidth/2) * Math.tan(slopeRad);

            // 法線 (垂直斜面向上)
            const normalX = Math.sin(slopeRad);
            const normalY = -Math.cos(slopeRad);

            const startX = spawnXOnSlope + normalX * (standingHalfHeight + slopeThickness/2);
            const startY = spawnYOnSlope + normalY * (standingHalfHeight + slopeThickness/2);
            
            flipoBody = Bodies.circle(startX, startY, rPx, {
                friction: fric,
                restitution: rest,
                frictionAir: 0.001, // 微量空氣阻力增加數值穩定性
                frictionAngular: rollFric,
                density: 0.01,
                render: { fillStyle: '#00E676', strokeStyle: '#fff', lineWidth: 2 }
            });

            Body.scale(flipoBody, ratio, 1);
            // 初始角度直立：斜面角度 + 90度
            Body.setAngle(flipoBody, slopeRad + Math.PI/2);

            Composite.add(engine.world, [slopeBody, flipoBody]);
            Render.lookAt(render, flipoBody, { x: 500, y: 400 });
        }

        function updateLoop() {
            if (isPaused || !flipoBody) return;

            // 即時讀取幾何參數供繪圖與計算使用
            const radiusM = parseFloat(document.getElementById('radius').value);
            const ratio = parseFloat(document.getElementById('aspectRatio').value);
            const rPx = radiusM * PX_PER_METER;

            // 處理時間步長 (避免 Infinity)
            let dt = engine.timing.lastDelta / 1000;
            if (dt <= 0.0001) dt = 0.0166;

            simulationTime += dt;

            const slopeRad = slopeBody.angle;
            
            // --- 角度計算 (Relative Angle) ---
            let rawRelAngle = flipoBody.angle - slopeRad;
            // 將角度正規化到 [0, PI]
            let theta = Math.abs(Math.atan2(Math.sin(rawRelAngle), Math.cos(rawRelAngle)));
            // 由於是對稱橢圓，超過 PI/2 就視為另一面，做鏡像處理
            if (theta > Math.PI/2) theta = Math.PI - theta;

            // --- 角速度 (Angular Velocity) ---
            const omega = flipoBody.angularVelocity / dt; 
            const omegaAbs = Math.abs(omega);

            // --- 線速度 1: 質心速度 (CoM Velocity) ---
            const v_cm_ms = flipoBody.speed / (PX_PER_METER * dt);

            // --- 線速度 2: 頂端點速度 (Tip Velocity) ---
            // 頂端點在局部座標 (rPx * ratio, 0)
            const rot = flipoBody.angle;
            // 轉到世界座標的偏移量
            const rx = Math.cos(rot) * (rPx * ratio);
            const ry = Math.sin(rot) * (rPx * ratio);

            // V_p = V_cm + omega x r
            // V_cm
            const vx_cm = flipoBody.velocity.x / dt;
            const vy_cm = flipoBody.velocity.y / dt;
            // omega x r (二維叉乘結果向量) -> (-omega*ry, omega*rx)
            // 注意 Matter.js 座標系 Y 向下，但 angularVelocity 方向定義一致
            const vx_tip = vx_cm - omega * ry; 
            const vy_tip = vy_cm + omega * rx;
            const v_tip_ms = Math.sqrt(vx_tip**2 + vy_tip**2) / PX_PER_METER;

            // 數據安全性檢查
            const safeV = (isFinite(v_cm_ms) && v_cm_ms < 100) ? v_cm_ms : 0;
            const safeVTip = (isFinite(v_tip_ms) && v_tip_ms < 100) ? v_tip_ms : 0;
            const safeOmega = (isFinite(omegaAbs) && omegaAbs < 1000) ? omegaAbs : 0;

            // 更新面板
            document.getElementById('stat-time').innerText = simulationTime.toFixed(2);
            document.getElementById('stat-vel').innerText = safeV.toFixed(3);
            document.getElementById('stat-vel-tip').innerText = safeVTip.toFixed(3);
            document.getElementById('stat-omega').innerText = safeOmega.toFixed(2);
            document.getElementById('stat-theta').innerText = theta.toFixed(3);

            // 更新圖表 (過濾掉模擬最初不穩定的幾幀)
            if (simulationTime > 0.05) {
                // 降低採樣頻率以提升效能，每 3 幀更新一次圖表
                if (Math.floor(simulationTime * 1000) % 48 < 16) { 
                    graphV.push(simulationTime, [safeV, safeVTip]); 
                    graphOmega.push(simulationTime, safeOmega);
                    graphTheta.push(simulationTime, theta);

                    dataLog.push({
                        t: simulationTime.toFixed(4),
                        v_cm: safeV.toFixed(4),
                        v_tip: safeVTip.toFixed(4),
                        omega: safeOmega.toFixed(4),
                        theta: theta.toFixed(4)
                    });
                }
            }

            // 攝影機跟隨
            Render.lookAt(render, flipoBody, { x: 500, y: 400 });

            // 繪製視覺輔助 (軸線與頂點)
            const ctx = render.context;
            ctx.save();
            ctx.translate(flipoBody.position.x, flipoBody.position.y);
            ctx.rotate(flipoBody.angle);
            
            // 長軸
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,0.3)";
            ctx.lineWidth = 2;
            ctx.moveTo(-rPx * ratio, 0); ctx.lineTo(rPx * ratio, 0);
            ctx.stroke();

            // 頂點標記
            ctx.beginPath();
            ctx.fillStyle = "#EA80FC";
            ctx.arc(rPx * ratio, 0, 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function togglePause() {
            isPaused = !isPaused;
            runner.enabled = !isPaused;
            document.getElementById('pauseBtn').innerText = isPaused ? "繼續" : "暫停";
        }

        function exportData() {
            if (dataLog.length === 0) {
                alert("無數據可匯出");
                return;
            }
            let csv = "\uFEFFTime(s),V_CoM(m/s),V_Tip(m/s),AngularVel(rad/s),Theta(rad)\n";
            dataLog.forEach(d => {
                csv += `${d.t},${d.v_cm},${d.v_tip},${d.omega},${d.theta}\n`;
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flipo_full_data_${Date.now()}.csv`;
            a.click();
        }

        // UI 數值即時更新顯示
        document.querySelectorAll('input[type="range"]').forEach(input => {
            input.addEventListener('input', e => {
                document.getElementById('val-' + e.target.id).innerText = e.target.value;
            });
        });

        window.onload = init;
        // 視窗大小改變時重繪圖表尺寸
        window.addEventListener('resize', () => {
            if(graphV) graphV.resize();
            if(graphOmega) graphOmega.resize();
            if(graphTheta) graphTheta.resize();
        });
    </script>
</body>
</html>
